---
layout: post
title: 클린코드
date: 2019-01-04
description: 설명
img: post-2.jpg
tags: 클린코드
author: luis


---
1. 깨끗한 코드
모델이나 요구사항에 집중해야한다고 하는 사람이 있다. 하지만 코드의 도움 없이 요구사항을 표현하기란 불가능이라 주장.
나쁜코드는 생산성을 떨어뜨린다.
나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가답지 못하다.
중복을 피하라. 한가지 기능만 수행하라. 제대로 표현하라. 작게 추상화하라.

2. 의미있는 이름
- 발음하기 쉬운 이름을 선택하라. 동료간의 소통할 때 필요한듯.
- 접두어에 의존하지 않은 좋은 IDE를 쓰자. 접두어를 써서 옛날에 작성한 구닥다리 코드라는 징표를 남기지 말자.
- 인터페이스에 이름은 접두어를 붙이지 않는 편이 좋다. 접두어는 주의를 흐트리고 과도한 정보를 제공.
- 클래스 이름은 명사나 명사구. Manager, Processor, Data, Info 등은 피해라.
- 메서드 이름은 동사나 동사구. 접근사(get),변경자(set),조건자(is)
- 생성자 오버로딩이 필요할때는 정적 팩토리 메서드로 인수를 설명하는 이름을 사용.
- 특정문화에서만 사용하는 이름은 피하라.
- 한 개념에 한 단어를 쓰자. get, fetch 혼용하지 말고 controller, Manager 혼용하지 말라.
- 맥락이 다르면 다른 이름을 써야한다. add로 합하는 메서드가 있는데 집합에 추가하는 메서드에 add를 쓰면 안된다. insert나 append를 써야한다. **메서드에 의미를 밝혀라. 메서드를 해독할 일이 생기면 안된다.**
- 코드를 읽을 사람은 프로그래머이기에 기술 네이밍 적극 사용해야한다. 도메인 이름보다는 기술 이름이 더욱 적합할 수 있다.
- 적절한 기술 용어가 없다면 도메인 네이밍을 써라.
- 메서드안에서 쓰는 변수가 메서드 전반에서 쓰이는데 의미가 불분명하다면 클래스로 분리해서 클래스안의 변수의 맥락을 분명하게 만들어라.
- 불필요한 맥락을 없애라. Gas Station Deluxe 라는 애플리케이션 짠다고 GSD로 시작하는 클래스로 만들면 바람직하지 못하다.

3. 함수
- 작게 만들어라. 작게 만들고 if,while문에 들어가는 블록은 한줄로 만들어라.
- 함수는 **한가지**를 해야한다. 그 **한가지**를 잘해야한다. 그 **한가지**만을 해야한다. (추상화 수준이 하나인 단계)
- 함수가 확실히 '한가지' 작업만 하려면 함 수 내 모든 문장의 추상화 수준이 동일 해야한다.
- 위에서 아래로 코드를 이야기 처럼 읽히면 좋다. 함수 안에 호출되는 함수들은 더 낮은 추상화를 가지게 된다.
- switch문은 작게 만들기 어렵다. 하지만 각 switch문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법은 있다.
```
public Money calculatePay(Employee e) throws InvalidEmployeeType{
  switch(e.type) {
    case COMMISSIONED :
      return calculateCommissionedPay(e);
    case HOURLY :
      return calculateHourlyPay(e);
    ...
    default:
      throw new InvalidEmployeeType(e.type);
  }
}
```
함수가 길다. 새직원 추가 될때 마다 길어지고 한가지 작업만 수행하지 않는다. (커미션직원, 시간직원등에 대한 작업), 코드를 변경할 이유가 많다. (SRP위반), 새 직원 생길때 마다 변경되야한다. (OCP위반)
가장 심각한건 isPayDay나 deliverPay같이 비슷한 코드가 여럿 발생 할 수 있다는 것이다.
이를 해결하기 위해 switch문을 추상팩토리에 꽁꽁 숨긴다. 팩토리는 switch문으로 적절한 Employee 파생 클래스를 만들어낸다. 이제 calculatePay,isPayDay,deliverPay같은 함수는 Employee인터페이스를 통해 실행된다.
```
public abstract class Employee {
  public abstract boolean isPayDay();
  public abstract Money calculatePay();
  public abstract void deliverPay(Money money);
}
-----
public interface EmployeeFactory {
  public Employee makeEmployee( EmployeeRecord r) throws InvalidEmployeeType;
}
------
public class EmployeeFactoryImpl implements EmployeeFactory {
  public Employee makeEmployee(EmployeeRecord r)throws InvalidEmployeeType {
    switch (r.type) {
      case COMMISSIONED:
        return new CommissionedEmployee(r);
      case HOURLY:
        return new HourlyEmployee(r);
      case SALARIED:
      ...

    }
  }
}
