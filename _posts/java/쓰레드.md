# 쓰레드

쓰레드를 쓰기위해서는 thread클래스를 상속하여 run메소드를 오버라이딩한다.

그리고 인스턴스화해서 run메소드를 호출하는것이 아니라 start메소드를 실행한다. 왜냐하면 start메소드는 쓰레드를 메모리공간에 활당받고 run을 실행하기 때문이다. 그냥 run쓰면 메모리 활당없이 실행되서 안된다.

 

main메소드가 종료되더라도 main쓰레드가 종료된것이기 때문에 남은 쓰레드까지 실행이 완료 되어야 프로그램 종료

 

별도의 실행흐름을 형성하기 위해서 자바 가상머신에 의해 만들어 지는 모든 리소스와 각종 정보들을 총칭해서 쓰레드라 한다.

Thread를 상속하는 클래스를 가리켜 '쓰레드 클래스' 이를 기반으로 생성되는 인스턴스를 가리켜 '쓰레드 인스턴스'

 

쓰레드클래스가 상속해야 할 또 다른 클래스가 존재한다면 Runnable인터페이스를 구현한다.

해당 클래스를 인스턴스화 하고 Thread를 인스턴스화 할때 인자로 넣고 start를 실행한다.

 

join은 해당 쓰레드가 종료 될때까지 잡아 놓는 것이다.

 

setPriority getPriority 쓰레드 우선순위

Thread.Max_PRIORTY, Thread.NORM_PRIORITY, Thread.MIN_PRIORTY 식으로 변경하는것이 좋다 왜냐하면 운영체제마자 우선순위가 다르기 때문

 

CPU의 할당이 필요치 않은 입출력을 처리하는 상황에 놓였을 때 쓰레드는 무리하게 CPU를 차지하려 하지 않고 다른 쓰레드들에게 넘긴다.

 

New 상태 - 쓰레드 클래스가 인스턴스화 된 상태

Runnable 상태 - 스케줄러에 의해 선택되어 실행 될 수 있기만을 기다리는 상태 , 스케줄러에 의해 선택 되어야 run 메소드가 처음 호출

Blocked 사태 - 실행 중인 쓰레드가 sleep, join메소드를 호출하거나 CPU의 할당이 필요치 않는 입출력 연산을 하게 되면 CPU를 다른 쓰레드에게 양보하고 Blocked상태가 된다

Dead 상태 - run메소드의 실행이 완료

 

쓰레드는 스택영역만 존재하며 메소드영역과 힙영역을 공유한다.

힙영역을 공유한다는 것은 인스턴스를 공유할수 있다는 것.. 즉, 데이터 통신이 힙영역을 통해 가능하다

 

Sum s = new Sum();

AdderThread at1 = new AdderThread(s,1,50);

AdderThread at2 = new AdderThread(s,51,100);

이처럼 s인스턴스를 공유할수있다 만약 자신만의 힙이 존재한다면 각 AdderThread 안 힙영역에서 s를 찾고 있을것이다 하지만 main Thread의 힙영역에 s가 있기때문에 없겠지?

 

만약 두 쓰레드가 어떤 값을 증가 연산한다고 하면 한 스레드가 어떤 값을 증가 시키고 바뀐 값을 저장하기 전에 다른 쓰레드가 증가 연산을 한다면 안된다.

따라서 한 쓰레드가 어떤 값에 접근해서 연산을 완료할때까지 다른 쓰레드가 변수 num에 접근하지 못하도록 막아야 한다. 이것이 동기화(Synchronization) 이다.

 

StringBuffer 클래스가 쓰레드에 안전하다. 이미 동기화 처리 되어있기 때문에 따로 동기화 처리 안해도 됨.

 

동기화 방법 ex ) public synchronized int add(...)

 

동기화를 한다는것은 자물쇠를 잠구는 것이다 자바의 모든 인스턴스는 하나의 열쇠가 있다 따라서 하나의 동기화메소드에 한 쓰레드가 접근하고 있을때 다른 동기화된 메소드는 접근이 불가 하다.

 

동기화하면 대신 속도가 저하된다.

동기화가 필요없는 부분까지 동기화로 잡아놓아서 그런것!

따라서 블락으로 구성할수있다.

 

public int add(int n1, int n2) {

synchronized(인스턴스 ex : this, Object 클래스 인스턴스화 된것)

{

opCnt++;

}

return n1+n2;

 

}

 

쓰레드의 실행 순서는 소스코드가 나열된 순서와 다를 수 있습니다.

쓰기 쓰레드와 읽기 쓰레드가 있는데 읽기 쓰레드가 먼저 실행되는것을 막기위해 동기화 블락 또는 동기화 메소드 안에 wait()로 기다리게 하고 notify/notifyAll로 깨우면 된다. 동기화 블락 안에 넣는 이유는 동시에 wait, notify 하지 않기 위해서 이다.

 

자바 5.0부터 동기화 대체 하는 방법

private final ReentrantLock key=new ReentrantLock(); 으로

key.lock();

try{

...}

frinally

{

key.unlock();

}

으로 동시 접근 막을수 있다.

 

wait, notiry 대체 방법

ReentrantLock 인스턴스를 대상으로 Condition 인터페이스를 구현하는 인스턴스의 참조값을 반환 해서 반환된 인스턴스를 대상으로 다음의 메소드를 호출 가능

await, signal, signalAll