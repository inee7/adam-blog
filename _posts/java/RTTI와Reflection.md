자바 프로그램의 실행 중에 타입 정보를 알아낼 수 있으며 또한 사용도 가능

런타임 시에 객체와 클래스의 정보를 알아내는 방법

\* 전통적 RTTI : 컴파일 시점에 사용 가능한 모든 타입을 클래스에 내포

\* 리플렉션 : 런타임 시에 클래스의 정보만을 알고 사용할 수 있는 것.

OOP의 다형성은 전통적 RTTI로 자바 컴파일시의 상속구조를 파악하여 동작

 

 

RTTI의 필요성 : 자바 다형성을 동작 시키는 중요한 내부 원리

\* 새로운 클래스가 파생 되어 프로그램이 확장 되어도 대부분의 코드가 영향을 받지 않는다.

\* 일반적으로 상위 클래스로 하위 클래스를 업캐스팅한 후 상위 클래스의 참조를 통해 사용하므로 상위 클래스 참조를 통해 코드 분량이 줄고 유연성과 확장성이 풍부해짐

\* 이렇게 동작하는 기본 원리는 컴파일 할 때 상속 구조 전체 타입 정보가 포함되어 RTTI가 동작

 

 

Class

\* Java Run-time시 타입 정보를 표현하는 클래스의 다양한 정보 가짐

\* Meta-Class

\* 모든 인스턴스를 내부적으로 이 클래스를 이용해 생성하여 RTTI의 기본 동작 원리를 제공하는 중요한 클래스

\*  J2EE 기반에 동작하는 모든 클래스를 적재, 생성하고 상속 구조를 클래스에 심어주어 WAS가 읽어 응용하는 기본적인 원리 제공

\* 자바를 이용해 R&D 프로젝트를 수행 할 시에 Reflection, Thread와 함께 사용되는 중요한 기술이며, 안드로이드의 동작 원리를 깊이 있게 이해 할 때도 중요

\* 동적 로딩 기술은 적재 시킬 자바 코드\[악성코드\]의 보안 검사에도 굉장히 중요한 역할

 

Class 사용 목적

\* 클래스의 자료형을 알아 낼 때 사용

\* 동적 자료처리

\* 늦은 바인딩을 톨한 효율성

\* 동적 클래스 로딩

\* 보다 유연한 클래스 로딩을 통한 다이나믹한 프로그래밍을 가능하게 해준다는 것이 가장 큰 장점

 

Class getClass\(\)

\* Class 객체 리턴

 

Class.forName\(String className\)

\* 클래스 동적 로딩

Object newInstance\(\)

\* 동적 인스턴스 생성

 

Reflection

\* 사용 가능한 메소드들을 찾아내어 그 메소드 이름을 알려주고 동적으로 실행되는 메커니즘

\* JavaBeans를 이용한 컴포넌트 기반 프로그래밍 기법에서 사용

\* Class클래스가 자바에서는 Reflection 개념을 지원 , 이와 관련된 라이브러리는 java.lang.reflection Package,Field,Method,Constructor

\* Java Reflection API의 라이브러리 대부분은 Run-Time시에 JVM이 생성하며 Unknown-class에 대응되는 멤버를 표현하고 동적 실행하는 역할을 담당

\* 반드시 해당 클래스가 로딩되어 있어야 한다. 즉, RTTI는 컴파일 시점에서 .class파일을 OPEN하고 검사하며, Reflection을 사용하면 .class 파일 자체가 필요하진 않지만 Run-Time시 OPEN되어 검사됨

\* 자바의 직렬화동작의 한 부분이 바로 Reflection을 이용한 메커니즘

\* Eclipse 같은 IDE Tool의 메소드 / 필드 보기는 바로 이 기능을 구현 한것

 

