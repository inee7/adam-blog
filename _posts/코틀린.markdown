# 왜 자바가 있는데 코틀린 해야하지?

**실용성 가독성 안전성 유지보수성**

자바로 개발 했던 곳에 코틀린으로 **100%**호환



오라클 vs 구글 -> 오라클 승!! 

오라클 자바 업데이트 하려면 구독료 내라 

구독료 내면 되지만 무료 오픈소스인 코틀린



# 코틀린 목적 및 철학

자바코드 남겨두고 그 위에 새로운 언어 쓰고 싶은 마음에서 시작.. 

서버,데스크탑,모바일 모든 환경에서 다 쓰고자 했다. 

모든 언어를 위한 상업용 언어로 개발 시작.

연구를 위한 언어가 아니다. 

이미 인증된 설계 철학에 의존. (OOP, FP)

==실용성에 초점.== 항상 도구의 활용을 염두에 두고 설계됨. 인텔리제이 아이디어의 개발과 컴파일러의 개발이 맞물려 있음. 

==높은 가독성== 코틀린은 프로그래머가 의미없는 코딩 (보일러플레이트)을 줄이기 위해 노력함. 번거로운 코드는 묵시적으로 제공 (게터,세터등등). 의도파악에 쉬움. 

==안전성== JVM의 안전성을 기반으로 더 나아가 NPE를 런타임에서 발생하지 않으며 클래스 타입 검사와 캐스팅을 동시에 진행할 수 있음 

==자바와 완벽 호환== 



#코틀린 개요 

- ==정적언어 + 타입추론== => <u>성능과 정확성 간결한 소스코드</u> 
- 객체지향과 *함수형프로그래밍* 모두 지원
  - 코틀린은 일급시민함수 지원, 람다식(코드블록쉽게정의), 데이터 클래스는 불변객체 간편하게 만들수 있는 구문 제공, 표준라이브러리에서 객체와 컬렉션을 함수형 스타일로 다룰 수 있는 API 제공 
    - 함수형 프로그래밍 : `일급시민함수(변수로가능)` 로 높은 추상화 가능 ( 공통되는 부분 함수로 뽑고 세부사항의 차이는 함수 인자로 전달), `함수 안에 불변 객체`를 통해 thread-safety (복잡한 동기화 불필요) ,  `pure function` (입력-출력 같고 다른 객체 상태 변경하지 않으며 함수 외부환경에 상호작용하지 않음) 으로 side effect 감소  
- 기존 ==자바 프레임워크 완벽 지원==. html생성기 영속화등의 일반적인 작업을 위한 새로운 도구 제공. 
- 오픈소스이며 ==주요IDE와 빌드 시스템을 완전 지원== 
- ==실용주의 언어. 자바와 완벽 대체 가능==
- 대화형 셀

* [코틀린 클라우드 코딩](try.kotlinlang.org)
* [코틀린튜토리얼](http://kotlinlang.org/docs/tutorials/)



- 코틀린 백엔드 준비 중...  (JVM 대체..)
- 코틀린 네이티브 준비 중... iOS, Android, MacOS 모두 코틀린으로 개발 가능하게. 



# 코드 맛보기

```kotlin
@Service
class TrackMetaService(private val trackAuthorityService: TrackAuthorityService, private val deliveryApiClient: DeliveryApiClient, private val memberAdultAuthorityService: MemberAdultAuthorityService, private val hanoverCacheManager: HanoverCacheManager, private val applicationContext: ApplicationContext, private val hanoverSecondCacheManager: HanoverSecondCacheManager, private val songApiClient: SongApiClient) {
    private val logger = LoggerFactory.getLogger(TrackMetaService::class.java!!)
    private var self: TrackMetaService? = null

    @PostConstruct
    private fun init() {
        self = applicationContext.getBean("trackMetaService") as TrackMetaService
    }

    /**
     * @throws com.kakao.hanover.i14y.I14yException api 연동 문제
     * @throws MelonSystemCheckTimeException        멜론 시스템 점검 중
     * @throws ResponseBodyException                응답값 이상
     * @throws NoSuchTrackException                 트랙을 찾을 수 없음
     */
    @Cacheable(value = "dto.v11.TrackSimpleDto", key = "#trackId.toString()", unless = "#result == null")
    fun getTrackSimpleDto(trackId: Long?): TrackSimpleDto? {
        val trackDto = self!!.getTrackDto(trackId!!)
        return convertToTrackSimpleDto(trackDto)
    }

    private fun convertToTrackSimpleDto(trackDto: TrackDto): TrackSimpleDto {
        val trackSimpleDto = com.kakao.hanover.dto.v11.TrackSimpleDto()
        trackSimpleDto.set(trackDto)
        return trackSimpleDto
    }

    fun getTrackSimpleDtoList(trackIdList: List<Long>): List<TrackSimpleDto> {
        val trackSimpleDtoList = ArrayList<TrackSimpleDto>()
        for (trackId in trackIdList) {
            val trackSimpleDto = getTrackSimpleDto(trackId)
            if (trackSimpleDto != null) {
                trackSimpleDtoList.add(trackSimpleDto)
            }
        }
        return trackSimpleDtoList
    }

    /**
     * @throws com.kakao.hanover.i14y.I14yException api 연동 문제
     * @throws MelonSystemCheckTimeException        멜론 시스템 점검 중
     * @throws ResponseBodyException                응답값 이상
     * @throws NoSuchTrackException                 트랙을 찾을 수 없음
     */
    @Cacheable(value = "dto.v11.TrackDto", key = "#trackId.toString()", unless = "#result == null")
    fun getTrackDto(trackId: Long): TrackDto {
        val songInfoResponse = songApiClient.getSongInfo(HanoverContext.getCpKey(), HanoverContext.getCpId(), HanoverContext.getUserAgent(), trackId)

        if (songInfoResponse.isPresent) {
            return convertToTrackDtoWithCheckBgm(songInfoResponse.get())
        }

        logger.info("(SongInfo Api) track is not found : {}", trackId)
        try {
            return getTrackDtoFromContentInfoApi(trackId)
        } catch (e: MelonApiStatusCodeException) {
            throw NoSuchTrackException(e)
        }

    }
```



---



# 코틀린 문법 기초 

##자바와 차이점

``` kotlin
fun main(args: Array<String>) {
    println("Hello, world!")
}
```

꼭 클래스 안에 함수 넣을 필요 없음 , 최상위 수준에 정의 가능 

`배열도 클래스와 마찬가지` 배열에 관한 문법 없음 

println 표준 라이브러리 간결하게 쓸수 있게 래퍼 제공

`세미콜론 붙이지 않아도 됨` 



> 자바에서는 모든 제어구조가 문이지만 코틀린은 `루프제외하고 대부분 식` 
>
> 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여 가능
>
> 자바에서 `대입(assign, =)`은 식이었으나 코틀린에서는 문이 되었다. 따라서 아래와 같은 차이가 있다.
>
> ```java
> /* 자바 */
> 
> /* line = bufReader.readLine() 으로 할당을 하면서
> 바로 != null로 비교 가능하다 */
> while((line = bufReader.readLine()) != null) {
>     ...
> }
> ```
>
> ```kotlin
> /* 코틀린 */
> 
> /* 대입(=)이 문이므로 아래 while 조건문 안의
> (line = bufReader.readLine()) 자체가 컴파일 에러다 */
> while((line = bufReader.readLine()) != null) { // <-- 이 문장은 오류다
>     ...
> }
> ```

##식이 본문인 함수 

```kotlin
/* 위 함수를 간소화 하면 아래와 같다 */
fun main(a: Int, b: Int): Int = if (a > b) a else b

/* 위 간소화 된 함수에서 리턴 타입을 제거하고 한 번 더 간소화 할 수 있다 */
fun main(a: Int, b: Int) = if (a > b) a else b
```

- `식이 본문인 함수`는 `타입 추론`을 통해 리턴 타입을 컴파일러가 결정 가능하므로 리턴 타입 생략이 가능하다.
- 등호와 식으로 이루어진 함수를 `식이 본문인 함수`라고 부른다.

##블럭이 본문인 함수

```kotlin
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}
```

- 함수의 본문을 중괄호로 감싸면 `블록이 본문인 함수`라고 부르고, 



## 변수

초기화를 하면 타입추론이 가능하다. 선언만 하면 타입 지정 해야한다. 

- `val(value에서 따옴)` - 변경 불가능(immutable) 참조를 저장하는 변수. 초기화 후에는 재대입이 불가능. 자바로 말하면 `final` 변수에 해당
- `var(variable에서 따옴)` - 변경 가능(mutable) 참조. 값은 바뀔 수 있다. 자바의 일반 변수에 해당
- 코틀린에서는 가능한 `val` 키워드를 사용해 불변 변수 사용을 권장. 나중에 꼭 필요한 경우에만 `var`로 변경하라
- `val` 변수는 정확히 한 번만 초기화 되어야 한다. 조건에 따라 다른 여러 값으로 초기화 가능하다. 아래 예제 참고.

```kotlin
val message: String
if (isSuccess()) {
    message = "Success"
}
else {
    message = "Failed"
}

```

- `val` 변수의 주의할 사항은 **참조 자체가 불변**이라는 점이다. **참조가 가르키는 객체 내부의 값은 변경 가능**하다. 아래 예 참고

```kotlin
val lang = arrayListOf("Java") /* 불변 참조를 선언 */
lang.add("Kotlin")             /* 참조가 아닌 객체 내부를 변경하므로 에러 아님 */
lang = arrayListOf("C")        /* 에러!! 참조를 변경 */
```

- `var` 변수는 값 변경은 가능하나, 초기화 시점의 변수 타입은 고정이다. 따라서 아래 예제는 오류를 발생한다.

```kotlin
var answer = 42
answer = "no answer"  /* 컴파일 에러!! Type mismatch */
```



## 문자열템플릿

```kotlin
fun main(args: Array<String>) {
    val name = if(args.size > 0) args[0] else "Kotlin"
    println("Hello, $name")
    println("Hello, ${name}")  /* 중괄호 사용 */
}
```

- 코틀린은 문자열 템플릿(String Template)을 지원한다. 아래 예제에서 println 안의 `$name`이 문자열 템플릿이다. 가능한 문자열 템플릿은 중괄호로 묶어 `${name}`처럼 사용하는 것이 좋다. 중괄호를 안 하고 한글과 같이 쓰면 컴파일할때 unresolved reference오류가 난다. 



## 클래스와 프로퍼티

```java
/* 자바 */
public class Person {
    private final String name;

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
```

```kotlin
/* 코틀린 */
class Person(val name: String)
// 이런 유형의 데이터만 있는 클래스를 값 객체라고 함 
```

- 확실히 줄어든 코드량 
- public 클래스가 기본



```kotlin
/* 클래스 안에서 변경 가능한 프로퍼티 선언 */
class Person (
    val nane: String,        /* 읽기전용 프로퍼티 */ 비공개필드,공개게터생성
    var isMarried: Boolean   /* 쓰기 가능한 프로퍼티 */ 비공개필드,공개세터,공개게터
)

>>> val Person("Bob", true)  new하지 않는다
>>> println(person.name)
Bob
>>> println(person.isMarried)
true
```

- 클래스라는 개념의 목적은 `캡슐화` 데이터를 다루는 코드를 한 주체 아래 가두는 것 
- 멤버 필드를 비공개로 하고 클라이언트가 쓸 통로를 만들어 허용한다. 
- 자바에서는 필드와 접근자를 한데 묶어 `프로퍼티`라고 함 
- 코틀린은 프로퍼티를 언어 기본으로 제공하여 자바의 필드와 접근자 메소드를 완전 대신 
- 프로퍼티는 val, var 둘다 가능
- new 키워드를 쓰지 않는다
- 프로퍼티 이름이 is로 시작하면 게터는 is- 그대로 쓴다 

```kotlin
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
        get() { /* <-- 프로퍼티 게터 선언 */
            return height == width
        }
        =>> get() = height == width
}

>>> val rect = Rectangle(41, 43)
>>> println(rect.isSquare)
false
```

- 커스텀 접근자를 쓴다고 성능상 차이는 없다 가독성 차이뿐