먼저 데스크탑 애플리케이션과 비교해보자.

데스크탑 애플리케이션은...

- 본인의 PC에서 처리가 진행된다. 
- 화면은 운영체제 기능으로 표시된다. 
- 애플리케이션을 설치해야된다.

웹 애플리케이션은...

- 서버 역할을 하는 PC에서 처리된다. 
- 화면은 웹브라우져가 HTML로 표시한다. 
- 설치가 필요없다. 

\- 인터넷에 연결된 어디서든 웹 애플리케이션을 이용할 수 있다.  





서버와 클라이언트

WWW를 통한 HTML 공개와 열람은 구체적으로는 웹서버(WWW서버 or HTTP서버)와 웹클라이언트라는 소프트웨어로 구현된다. 

웹 시스템 뿐아니라 현재의 컴퓨터 시스템에는 클라이언트-서버 모델이라는 형태가 폭 넓게 이용되고 있다. 

클라이언트와 서버라는 말은 각각 컴퓨터와 작동하는 소프트웨어를 가리킨다. 

WWW에서는 웹서버가 네트워크상에 공개하는 HTML을 웹클라이언트 요청에 따라 필요한 HTML파일을 건네주는 구조로 돼 있다. 

소프트웨어

웹 서버용 소프트웨어로는 오픈소스로 공개된 아파치 HTTP 서버와 마이크로소프트 IIS가 널리 이용. 

웹 클라이언트는 익스플로러,크롬,사파이 브라우저.

왜 클라이언트와 서버로 나누냐? 

WWW가 콘텐츠를 불특정 다수에게 공유하기 위한것이라서 콘텐츠를 잘 공유하는것이 중요하다. 

만약에 같은 콘텐츠가 여러 컴퓨터에 분산돼 있으면 콘텐츠 정보가 동기화되기 어려워진다. 

그래서 웹서버에 콘텐츠를 집중시킨다. 





WWW가 발명됨에 따라 인터넷상에 정보의 근간은 웹서버이다. 

그러면 웹클라이언트가 원하는 정보를 얻을때 어떻게 요청할까?

"뭐 주세요"해서는 받을 수 없다. 

"어디어디에 뭐 주세요" 라는 위치를 지정해줘야된다. 

그것이 URL이다. 

스킴://호스트명/경로명 

- 스킴

프로토콜 

- 호스트명

인터넷에 접속된 호스트 컴퓨터를 명칭한다. 

[www.naver.com](http://www.naver.com/)이라는 호스트명은 

www(로컬명)과 [naver.com](http://naver.com/)(부모도메인명)으로 이루어 진다. 

로컬명은 그 조직 안의 컴퓨터에 붙은 이름이고 부모도메인명은 해당 호스트의 조직을 나타낸다. 

부모도메인명은 인터넷상에 유일해야된다. 

- 경로명 

호스트명에서 지정된 컴퓨터상의 리소스 위치를 나타낸다. 

이처럼 URL을 이용하면 도메인-컴퓨터-디렉터리-파일명과 같이 계층적으로 찾는다. 





WWW가 발명됨에 따라 인터넷상에 정보의 근간은 웹서버이다. 

그러면 웹클라이언트가 원하는 정보를 얻을때 어떻게 요청할까?

"뭐 주세요"해서는 받을 수 없다. 

"어디어디에 뭐 주세요" 라는 위치를 지정해줘야된다. 

그것이 URL이다. 

스킴://호스트명/경로명 

- 스킴

프로토콜 

- 호스트명

인터넷에 접속된 호스트 컴퓨터를 명칭한다. 

[www.naver.com](http://www.naver.com/)이라는 호스트명은 

www(로컬명)과 [naver.com](http://naver.com/)(부모도메인명)으로 이루어 진다. 

로컬명은 그 조직 안의 컴퓨터에 붙은 이름이고 부모도메인명은 해당 호스트의 조직을 나타낸다. 

부모도메인명은 인터넷상에 유일해야된다. 

- 경로명 

호스트명에서 지정된 컴퓨터상의 리소스 위치를 나타낸다. 

이처럼 URL을 이용하면 도메인-컴퓨터-디렉터리-파일명과 같이 계층적으로 찾는다. 





다양한 종류의 컴퓨터가 웹서버와 웹클라이언트가 통신하기 위한 공통된 프로토콜이 필요했다. 

FTP나 SMTP는 이미 있었지만 HTML전송에 적합한 프로토콜이 없었다. 

그래서 만든것이 HTTP 프로토콜이다. 



인터넷에 공개된 기술 규격.

URL, HTTP등등



단순히 콘텐츠를 전 세계에 공개해 공유하는 것을 넘어 현재 웹애플리케이션으로 넘어오게 되는 계기가 있었다. 

그게 바로 CGI이다. 

웹에 대한 욕심..

웹서버는 준비돼 있던 콘텐츠를 클라이언트 요청에 응해 보내 주는 일을 했다. 

그러나 연구자뿐 아니라 다양한 사람들이 이용하게 되자 욕심이 생기게 됐다. 

기업 광고를 한다고 쳤을때 매번 같은 콘텐츠면 보는 사람 입장에서 끌리지 않게 된다. 

그래서 항상 새로운 콘텐츠를 제공하여 사람이 많이 보게 유도 하고 싶을 것이다. 

그렇다고 사람이 매번 새로운 콘텐츠를 만들고 웹서버에 올리는 작업을 반복하면 너무 힘들것이다. 

CGI 탄생

웹 서버에 작동하는 프로그램을 만들어 사람대신 콘텐츠를 생성하면 편하게 작업 할 수 있을것이다.  

그러한 프로그램과 웹서버를 연동할 수 있게 만든 규약이 CGI이다.

요청을 받으면 웹서버상에 작동하는 프로그램(Perl이나 C)에 보낸다. 

해당 프로그램은 HTML을 생성에 응답한다. 

또한 동적 콘텐츠 생성 뿐아니라 웹 브라우저에서 입력을 받아 처리를 하거나 게시판 등 발전하게 됐다. 



CGI를 둘러싼 문제

규모가 커지면서 펄로 개발하기 어려워졌으며 요청때마다 프로세스가 기동되어 성능이 안 좋았다. 

자바/서블릿의 탄생

제임스 고슬링이 개발한 자바가 등장하면서 상황이 달라졌다. 

자바는 객체지향을 완벽히 지원하여 대규모 시스템에 용이했다. (그밖에 보안,네트워크통신, 멀티스레드 지원도 매력적) 

원래 자바는 웹 애플리케이션 개발하기 위해 나온것이 아니었다. 

그러나 워낙 웹 애플리케이션이 주류였기 때문에 JavaEE의 일부로서 서블릿이라는 기능을 웹 애플리케이션 개발을 지원하기 위해 제공했다. 

서블릿

서블릿은 자바로 만들어진 HTML등의 웹 콘텐츠를 생성하기 위한 프로그램이다. 

웹서버와 프로그램이 별개의 프로세스로 도는 CGI 방식에서는 요청 받을때 마다 새로운 프로세스를 작동하지만 서블릿은 웹서버와 같은 프로세스 속에서 프로그램이 작동하기 때문에 매번 기동할 필요가 없어 속도가 빠르다. 

다만, 웹컨테이너를 설치하기가 웹서버만 설치 했을때 보다 어려웠고 객체지향 지식이 필요해서 대규모 시스템에서만 이용됐다. 

자바로 개발할 때의 이점 

자바는 플랫폼에 독립적이라서 서로 다른 플랫폼에서 같은 프로그램을 실행할 수 있다. 

기존에는 웹 서버의 플랫폼과 동일한 플랫폼에서 개발하는 것이 원칙이었지만 자바로 개발하면 상관이 없었다.



대규모 웹 애플리케이션에서 서블릿은 하나의 파일을 가지고 디자이너와 개발자가 함께 작업하기 어려운 점이 있었다. 

그래서 조금이라도 개선하기 위해 고안된 것이 JSP라는 기술이다. 

HTML 개발 부분과 자바 개발 부분을 분업할 수 있게 됐다. 



웹 애플리케이션의 규모가 엄청나게 커지게 된다. 

많은 사람들이 개발에 관여하게 되고 시스템 복잡도가 증가하며 불협화음도 커지게 된다. 

따라서 재사용이라는 발상으로 프레임워크를 만들어 냈다. 



애플리케이션      

------

웹 애플리케이션  

프레임워크                  HTTP       웹브라우저

------

애플리케이션 서버                       플랫폼

------

JVM         

------

플랫폼

​      서버측                            클라이언트 측 

___________________________________________________

그림처럼 웹서버와 웹클라이언트는 HTTP프로토콜을 통해 통신한다. 

요청시 HTTP 상세 내용

- Request Header

a. 메서드

GET(read), POST(update), PUT(create), DELETE(delete)

b. URI

what에 해당한다. 

c. HTTP 버전 

- Message Header : 요청의 부가정보들

d. Accept

웹 클라이언트가 받을 수 있는 데이터의 종류. 

HTTP통신 가능한 소프트웨어면 클라이언트가 될 수 있다. 

소프트웨어마다 받을 수 있는 정보가 달라서 지정이 필요하다.  

지정하면 웹 서버에서 불필요한 정보를 송신하지 않아도 된다. 

e. Accept-Language 

웹 클라이언트가 받을 수 있는 언어의 종류. 

f. User-Agent

웹 브라우저의 종류와 버전. 

클라이언트 종류에 맞춰서 최적의 콘텐츠를 돌려주기 위해서이다. 

스마트폰이면 스마트폰에 맞혀서 콘텐츠를 내려준다. 

사이트 사용자의 브라우저 통계도 알 수 있다. 

g. Host 

요청 보낸곳의 호스트명과 포트번호. 

응답시 HTTP 상세 내용

- 상태라인 

a. http버전 

b. 상태코드

요청의 성공/실패 여부 

1XX : 요청 처리가 계속 되고 있음

2XX : 성공 

3XX : 리다이렉션 

4XX : 요청 실패 (클라이언트측 에러) 

401 : 사용자 인증 실패 

403 : 권한 없음 

404 : Not Found

5XX : 요청 실패 (서버측 에러) 

500 : Internal Server Error

c. 응답 구문 

OK같은 메시지

- Message Header

응답의 부가정보들

- Message Body 

메시지의 본문. HTML이나 콘텐츠들. 

HTTP는 요청 한번에 하나의 리소스만 !

어떤 html 리소스를 요청했을때 html 태그 안에 이미지 태그가 있으면 이미지 리소스를 가져오는 http 요청이 한 번 더 가게된다. 

파일명 생략하고 요청 보내면 index.html이나 default.html로 



IP주소를 알면 특정 호스트로 정보를 보낼 수 있다. 

TCP/IP는 요청정보를 배달해주는 역할을 한다. 

정보를 패킷이라는 단위로 분할해서 인터넷을 경유해서 목적지에 패킷을 복원해서 웹 서버에 준다. 

IP 주소는 누가 결정하는가?

집에서 사용하는 IP는 인터넷 서비스 프로바이더 (ISP)에서 확보한 IP 주소 중 하나를 일시적으로 할당 받는 것이다.  

글로벌 IP 주소

ISP에서 할당한 인터넷상에서 유일한 주소가 글로벌 IP 주소이다. 

사설 IP 주소

인터넷이나 다른 네트워크에 접속되지 않는 네트워크를 사설 네트워크라고 한다. 

IP 주소는 인터넷에 접속된 호스트를 식별하기 위한 것이다. 그러므로 사설 네트워크상에서 글로벌 IP 주소를 사용할 필요는 없다. 

어떤 사설 네트워크에서 사용 되고 있는 IP주소가 다른 사설 네트워크에서도 사용되고 있더라도 서로 네트워크가 연결돼 있지 않아서 아무런 문제도 일어나지 않는다. 

그래서 등장한것이 사설 IP주소. 

사설 IP 주소는 어떤 일정 범위의 IP주소를 사설 네트워크에서 자유롭게 이용할 수 있게 예약한 것이다.  

글로벌 IP주소는 일반 유선번호고 사설 IP주소는 내선 번호와 같다. 

사설 IP주소 범위 

10.0.0.0 ~ 10.255.255.255 클래스A 

172.16.0.0 ~ 172.31.255.255 클래스B

192.168.0.0 ~ 192.168.255.255 클래스C 

호스트명 - IP주소 바꿔주는 DNS  

url에 호스트명을 적으면 IP주소로 바꿔주는 역할. 

포트 

TCP/IP가 수신 측 컴퓨터까지는 찾아냈는데 어떤 프로토콜의 것이고 어떤 애플리케이션에서 처리해야 되는지는 알지 못한다. 

그래서 등장 한것이 포트이다. 

애플리케이션은 반드시 수신 대기 포트를 결정하고 정보를 기다려야한다. 

포트는 컴퓨터안에 애플리케이션이 정보의 수신을 기다리기 위한 항구의 부두이다. 

포트는 65,536개가 있고 일부는 표준으로 정해 놓았다. 

그런데 인터넷 브라우저에 [naver.com](http://naver.com/)을 치면 잘 된다. 그것은 80포트가 생략되어 있어서이다.  

생략된 이유는 예전에 자유롭게 포트를 정하다보니 같은 HTTP라도 포트가 제 각각이라 불편했다. 

그래서 자주 사용하는 포트를 정해놓고 브라우저에서 url에 포함된 스킴을 통해 자동으로 포트를 만들어낸다. 

자주쓰는 포트 

20,21 FTP

22 SSH

23 Telnet 

25 SMTP

53 DNS 

80 HTTP

110 POP3

443 HTTPS



GET 요청 

[http://url?arg1=123&arg2=456](http://url/?arg1=123&arg2=456)

에서 ?arg1=123&arg2=456 이 부분이 바로 쿼리스트링이다. 

쿼리 스트링으로 요청파라미터를 웹서버에 보낼 수 있는데 GET방식은 라인속에 포함된다. 

POST 요청

GET과 달리 요청파라미터는 메시지 Body에 들어있다. 

이로인해 url에 노출되지 않고 길이에 걱정할 필요가 없다 .

요청 파라미터에 한글은?

한글과 공백은 요청파라미터에 넣을 수 없다. 

방법은 퍼센트 인코딩을 해야 요청파라미터에 넣을 수 있다. 

보통 브라우저에서 자동으로 퍼센트 인코딩을 처리한다. 





HTTP는 원래 HTML로 쓴 문서를 열람하기 위해 고안된 것인데, 쿠키와 세션을 사용하면 사용자와의 정보 송수신을 연속된 흐름으로서 제어할 수 있다. 

FTP는 telnet으로 서버에 접속을 하면 로그인을 해야 내 디렉터리를 알 수 있다. 

이것은 FTP서버가 앞선 요청을 기억하고 있으면서 그것을 바탕으로 다음 요청을 실행하기 때문이다. 

즉 상태 유지 프로토콜(Stateful Protocol)이다. 

그렇다면HTTP는?

무뚝뚝하다. 

HTTP는 한 번의 요청만으로 용건이 해결되어 상태를 보존하지 않는다. 

즉 무상태 프로토콜 (Stateless Protocol)이라고 한다.  

WWW를 고안했을 당시 FTP가 이미 있었는데 왜 HTTP를 새로 만들었을까?

그것은 통신 절차가 많아 오버헤드가 크고 접속을 위해 인증이 필요해서 간단한 HTTP프로토콜이 필요했던거다. 

근데 요즘 웹은 로그인하고 상태가 보존 되지 않느냐? 

그것은 HTTP 설계할 당시 HTTP로 웹 애플리케이션을 구현하리라 생각하지 않았기 때문이다. 

점점 웹이 발전하면서 로그인정보를 매번 편하게 확인하기 위해 쿠키와 세션가 추가 설계 되었다. 

쿠키

get을 통해 로그인 정보를 보내면 노출 될 것이고 post를 통해 보내면 매번 폼태그를 포함 시켜야 되고... 골치다. 

그래서 쿠키로 한 번 로그인 정보를 교환 해보겠다. 

로그인 요청을 보내면 서버에서 응답을 보낸다. 

그 응답헤더에 쿠키를 넣어서 보낸다. (웹서버에서 구현해야함) 

브라우저는 쿠키를 저장하고 같은 웹서버 요청때마다 쿠키를 헤더에 넣어서 보내게 된다. 

로그아웃하면 서버에서 쿠키를 삭제하도록 응답헤더에 알려주고 브라우저에서 삭제하게 된다.

원래는 넷스케이프라는 웹 브라우저에서 만든 기술이었는데 나중에 표준화 됐다. 

근데 쿠키는 보안상 위험하다. PC에 저장되어있는 쿠키를 까보면 그만이기 때문이다. 

세션

우리가 로그인하고 쇼핑을 하고 주문을 하고 로그아웃을 하는 일련의 처리흐름을 세션이라고 한다. 

그렇다면 여러 단계에 걸쳐 흐름이 진행 될텐데 이 흐름의 상태를 보존하고 있어야 한다. 이것을 세션 상태라고 하자. 

세션상태는 서버측 메모리나 DB에 저장되어있다. 

클라이언트와 서버는 세션ID라는 고유의 식별자를 가지고 주고 받는다. 

웹 애플리케이션에서의 로그인처럼 세션을 개시할 때는 웹서버 측이 새로운 세션 ID를 발행해서 쿠키에 저장한다. 

클라이언트는 다음 요청부터 쿠키를 보내어 서버에서 세션 ID를 꺼내 세션 상태들을 복원시킨다. 

이렇게 함으로써 쿠키에 저장할 수 있는 정보량의 제한을 무시하며 안전성도 높아졌다. (물론 세션 ID 도둑 맞으면 해당 서버의 데이타는 털린다. 상대적으로 안전할 뿐.) 



앞서 웹 애플리케이션이 어떻게 발전했는지 공부했었다. 

웹서버와 웹클라이언트 사이 정적 HTML을 주고 받기위해 HTTP를 고안했고 

CGI방식을 통해 동적 HTML을 생성하는 프로그램을 웹서버가 구동시켜 동적 HTML을 만들어내어 뱉어냈다.  

다만, 동적HTML 만드는 프로그램이 요청때마다 살아났다 죽었다를 반복해서 속도가 떨어졌다. 

반면 애플리케이션서버 방식은 웹서버와 애플리케이션서버가 연동하는 방식인데 애플리케이션서버를 실행시키기 위한 JavaVM 프로세스가 항상 살아있어 속도가 상대적으로 빨랐고 그 위에 애플리케이션 서버가 올라가있고 그 위에 웹 애플리케이션을 통해 서블릿/JSP가 생성되어 재활용등의 장점이 있었다.(JAVA의 인기가 한 몫한것도 있다.)

디자인 영역을 떼어내면서 JSP까지 발전했고 다양한 프레임워크가 생겨났다. 

그렇게 웹서버 사이드는 발전했다. 

소규모 웹 서비스에서는 한 컴퓨터 안에서 웹서버, DB서버를 둘 수 있지만 조금만 규모가 커지면 다운되기 쉽상이다. 

그래서 DB서버를 다른 컴퓨터에 두고 웹서버와 통신하는데 그때 DB 제품에 맞는 프로토콜을 구현한 라이브러리가 JDBC 같은 것이다.

웹서버와 웹애플리케이션서버는 다른 프로세스이므로 서로 연동하려면 통신을 해야했다. 

근데 통신방법이 표준화 돼있지 않다. 그래서 웹서버측에 연동모듈을 탑재해 통신하게된다. 

웹서버에 요청이 들어오면 웹애플리케이션서버에 연동모듈을 통해 요청을 전달하고 웹애플리케이션에서 요청을 처리하고 응답을 보낸다.(웹서버는 대게 아파치, 웹애플리케이션서버는 톰캣 , 둘 사이에 고속을 위해 톰캣 고유의 프로토콜도 존재..)

통상적으로 웹서버쪽에는 정적콘텐츠만 배치하고 웹애플리케이션서버에는 동적콘텐츠를 배치한다. 

이처럼 서버 사이드에서는 프로세스 두 개가 연동하는데 HTTP요청 중 애플리케이션이 처리할 부분만 애플리케이션서버에 전달한다. 

그렇다면 웹 서버는 어떻게 해서 애플리케이션 서버로 전송해야 할 URL인지 구분할까?

컴퓨터가 판단할 수 없고 우리가 가르쳐 줘야한다. 

웹서버에 톰캣과 연동하는 모듈이 설정 파일을 읽는다. 

HTTP요청을 전송할 톰캣에 관한 정보를 담는 파일에는 톰캣 워커라는 톰캣프로세스의 이름과 애플리케이션서버의 호스트명과 포트번호와 톰캣과 통신할 프로토콜이 담겨져있다. 

아파치의 설정파일에는 위 파일의 위치와 아파치가 받은 HTTP요청 URL 중 톰캣에 보낼 URL이 지정 되어있다. 

웹서버는 많은 클라이언트의 요청을 받는다. (정적 콘텐츠 하나하나 요청 다 보내기 때문에..) 

웹애플리케이션서버는 대신 한번의 요청에 무거운 처리를 진행한다. 

이처럼 서버당 성격에 맞게끔 컴퓨터를 분담하면 된다. 

톰캣워커는 여러개 두어 이중화 할 수 있다. 

근데 대부분의 애플리케이션서버는 웹서버 기능도 할 수 있다. 

그래서 단순히 애플리케이션서버만 둘 수도 있는데 이렇게 되면 웹서버-웹애플리케이션서버간의 연동 작업도 필요 없어서 단순한 구조가 된다. 

웹애플리케이션서버(WAS)가 제공하는 기능

- 세션관리
- 트랜잭션 관리 
- DB접속관리
- 웹애플리케이션관리와 시스템 가용성/성능 향상 

최소 구성

클라이언트 사이드 - 서버 사이드 노드1( WAS -DB서버 ) 

: 소규모 시스템이나 개발환경 또는 테스트 환경에서 많이 쓴다. 

클라이언트 사이드 - 서버 사이드 노드1(웹서버 - WAS - DB서버) 

: 웹서버를 두어 이용가능하다. 세 프로세스 돌릴 만큼 노드(컴퓨터)의 사양이 높아졌다. 

일반 구성

클라이언트 사이드 - 서버 사이드 노드1(웹서버) - 서버 사이드 노드2(WAS) - 서버 사이드 노드3(DB서버) 

: 사용자와 데이타가 많은 대규모 시스템. (대기업이나 쇼핑몰) 

클라이언트 사이드 - 서버 사이드 노드1(웹서버-WAS) - 서버 사이드 노드2(DB서버) 

: 데이타는 많지만 사용자는 적은 시스템. (사내 시스템) 



OSS는 오픈소스소프트웨어이다. 

말 그대로 소프트웨어의 소스를 오픈하는것이다. 

아파치와 톰캣, 리눅스가 그러한 것이다. 

그런데 OSS에는 라이센스가 존재한다. 

카피라이트의 반댓말로 카피레프트형인 GPL은 저작권없이 누구나 복사/재배포/변경이 가능하다. 그리고 그렇게한 소프트웨어도 GPL이 된다. GPL쓰면 그냥 다 공개하고 내것이 아니게 된다. 

준 카피레프트형인 LGPL,MPL은 변경만 안했으면 소프트웨어의 소스를 공개하지 않아도 된다.

비 카피레프트형은 BSD와 아파치가 있는데 재배포하거나 변경하거나 지지리 볶아도 공개하지 않아도 된다. 아주 감사한 라이센스다. 아파치HTTP서버,톰캣등이 그런거다. 



JSP로 개발하다 JAVA코드가 너무 길어지면 지저분해졌다. 

그래서 JAVA코드는 서블릿쪽으로만 집중 시키고 JSP는 되도록 HTML에 집중 시켰다. 

리다이렉트가 아니라 포워드

JSP에서 이벤트가 발생했을때 대응하는 url이 있을것이다. 

그 url과 서블릿을 대응시키고 서블릿은 또 JAVA클래스와 대응시킨다. 

JAVA 클래스에서 동적처리를 진행하면 다음 JSP를 클라이언트에 보낸다.  

이것이 바로 포워드이다. 

서블릿에서 JSP로 이동이 브라우저를 통하지 않고 WAS 내에서만 진행하고 한 방에 갈 곳을 정해주는 방식이다. 

(cf. 리다이렉트는 브라우저에 요청을 하게 지시(302)를 내리고 브라우저가 다시 요청을 하게되는 HTTP를 두번 요청하는 방식이다. ) 

요청 스코프 

포워드 할때 요청 파라미터 바탕으로 서블릿에서 처리하고 그 결과를 JSP에 표시하도록 전달 방식이 필요하다. 

예를 들어 아이디를 받아서 서블릿에서 DB를 참조해서 이름을 JSP에 넘겨줄 때이다.

그때**요청스코프**를 이용한다. 

요청파라미터는 클라이언트에서 WAS로 넘겨줘서 WAS에서 읽기만 가능한 정보이다. 

읽어온 요청파라미터 값을 가지고 처리한 다음 요청스코프에 값을 쓴다.  (request.setAttribute())

이 요청스코프는 HTTP요청 1회에만 유효한다. 따라서 리다이렉트는 정보를 유지 할 수 없다. 

JSP에서 요청스코프의 정보를 태그를 이용해 추출한다. 

근데 세션으로 해결하면 안 되나?

안 된다. 

세션은 일단 HTTP규격이 아니라 WAS에서 자의적으로 구현한 것이다. 

따라서 WAS에서는 지속적으로 보존 될 수 있으나 클라이언트에서 스스로 세션 종료를 할 수가 없다. 

그리고 세션이 안 좋은게 메모리를 많이 잡아 먹는데 세션이 종료되지 않고 축적되면 서버가 버티기 힘들다. 

그래서 세션 접속 시간을 WAS에서 기록해서 타임아웃으로 자동 삭제하게 만들었다. (톰캣은 기본 30분)  

아니면 로그아웃 같은 이벤트에 세션을 삭제 하게 만들면 된다. 그래도 브라우저 닫기만 하면 세션 정보가 남는다. 결국 세션스코프는 어떤 이벤트로 웹애플리케이션에 의해 삭제 될때 까지 보존 되는거라 인증 쪽으로만 쓴다. 반면 요청스코프는 하나의 요청안에서만 유효하며 WAS가 제어한다. 



MVC패턴

요청을 받으면 

**컨트롤러**가 요청의 정보를 추출해서 모델에 넘긴다. 

**모델**은 정보를 처리하고 정상 처리를 했는지 컨트롤러에 알린다. 

**컨트롤러**는**뷰**를 호출한다. 

**뷰**는 모델에 표시할 정보를 추출하여 HTML로 출력해서 응답한다. 

레이어 패턴

시스템을 계층화하고 하위레이어가 제공하는 기능을 상위레이어가 이용함으로써 이용한다는 패턴이다. 

프레젠테이션 레이어는 비지니스로직 레이어를 이용하고 비지니스로직 레이어는 데이터엑세스 레이어를 이용한다. 

프레젠테이션 레이어에는 컨트롤러와 뷰가 있고

비지니스로직,데이터엑세스 레이어는 모델이 있다. 



데이타엑세스 레이어에서 JDBC를 이용하면 DB의 정보를 자바 객체로 다시 조립하는 코드가 많고 복잡했다. 

그러나 ORM은 관계형데이타베이스와 자바의객체를 매핑시켜 개발 작업을 효율화 할 수 있다. 

대표적인 ORM 프레임워크로는 mybatis, JPA...

